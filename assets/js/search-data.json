{
  
    
        "post0": {
            "title": "Exploring Monty Hall in python",
            "content": "Getting Started . I have started a course on probability from MIT Open courseware . In an attempt to solidify my learning and also get started on my blog I will try to code interesting problems/topics that I come across. . Starting with the Monty Hall problem. . In this notebook, I will attempt to: . Create a Simulation of a single trial of the Monty Hall Problem (with the option to switch) | Run the simulation multile number of times (with switching, without switching and random switchnig) and explore the results | Figure out if I can make the simulation faster | . To get started, lets define a function that takes in three inputs (Prize door #, Selected door #, Switch) and returns the result of the experiment (win or loss). . Additionally in this case, a win with switching is a loss without switching (and vice versa) . # Returns of the trial results in a win def MontyTrial(win_door, selected_door, switch = False): if (win_door == selected_door and not switch): return 1 elif (win_door == selected_door and switch): return 0 elif (win_door != selected_door and switch): return 1 elif (win_door != selected_door and not switch): return 0 . Simulating the trials . Now that we have a function that can give us the outcome of an individual trial, lets see if we can run multiple trials and find out what happens. . I will use a Numpy array to generate random winning door numbers and selected door numbers. . # Import numpy and datetime. I will use current UTC as the seed for Numpy&#39;s random number generator import numpy as np from datetime import datetime seed = datetime.utcnow().timestamp() #Testing generation of 10 random ints between 1 and 3 print(&quot;Seed: &quot;, int(seed)) np.random.seed(int(seed)) print(&quot;10 Random integers between 1 &amp; 3: &quot;, np.random.randint(1,4,10)) . Seed: 1611189363 10 Random integers between 1 &amp; 3: [2 2 3 2 3 2 1 2 1 2] . Having set that up, I will now generate two arrays of size 1000 each. One would be the winning door number and the other would be the selected door number. . Then we can feed in the results to the MontyTrial function and evaluate the results . Edit: Going to convert this into a function so that I can time the results . #This function runs Monty Hall trials for the given number of trials. #The supress variable will stop any output from the function for timing purposes def MontySimulation(trials, supress=False): if (supress == False): print(&quot;Simulating &quot;,trials,&quot; trials&quot;) Winning_Door = np.random.randint(1,4,trials) Selected_Door = np.random.randint(1,4,trials) Result = 0 #Running the trial where the contestant never switches for i in range(0, len(Winning_Door)): Result += MontyTrial(Winning_Door[i], Selected_Door[i], False) Result = Result/trials if (supress == False): print(&quot;Probability of winning with no switching: &quot;, Result) print(&quot;Probability of winning with always switching: &quot;, 1 - Result) MontySimulation(100000) . Simulating 100000 trials Probability of winning with no switching: 0.3345 Probability of winning with always switching: 0.6655 . Looking at the results above, the probability of winning is ~67% or 2/3rd of the time if an always switching strategy is adopted. . However I think this implementation is not optimal and there is an opportunity to speed it up. To start, I will time 1 million trials. . %timeit MontySimulation(1000000, True) . 1.03 s ± 442 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) . With the current logic, it takes about 1 second to run 1 million MontyHall trials. There is obviously room for improvement. To start, lets see if we can simplyfy the Monty Trial function . #In the v2 version of this function, I will try to reduce the for conditionals and run a trial to see if that improves performance def MontyTrialv2(win_door, selected_door, switch = False): result = 0 if win_door == selected_door else 1 return result == switch . Came down to a bit of a wierd logic, but this is what the function is doing: . If Winning door and selected door are the same then set result to 0, else set it to 1 | If there is no switching, then the variable switch is false (0) and so result would be equal to switch (and a win) | If result is one and no switching, then the return statement returns as false (1 == 0) | With switching (variable switch set to true) a zero resutls returns a false (since 0 != 1) | Finally, with switching set to true a 1 results returns True (since 1 == 1) | Lets plug this new function into a simulator and see if this speeds up the code . #V2 simulation fucntion uses the Monty V2 to generate results def MontySimulationv2(trials, supress=False): if (supress == False): print(&quot;Simulating &quot;,trials,&quot; trials in v2&quot;) Winning_Door = np.random.randint(1,4,trials) Selected_Door = np.random.randint(1,4,trials) Result = 0 #Running the trial where the contestant never switches for i in range(0, len(Winning_Door)): Result += MontyTrialv2(Winning_Door[i], Selected_Door[i], False) Result = Result/trials if (supress == False): print(&quot;Probability of winning with no switching: &quot;, Result) print(&quot;Probability of winning with always switching: &quot;, 1 - Result) MontySimulation(100000) MontySimulationv2(100000) . Simulating 100000 trials Probability of winning with no switching: 0.33616 Probability of winning with always switching: 0.66384 Simulating 100000 trials in v2 Probability of winning with no switching: 0.33048 Probability of winning with always switching: 0.66952 . print(&quot;Timing v1 Simulation on 1 million trials&quot;) %timeit MontySimulation(1000000, True) print(&quot;Timing v2 Simulation on 1 million trials&quot;) %timeit MontySimulationv2(1000000, True) . Timing v1 Simulation on 1 million trials 768 ms ± 81.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) Timing v2 Simulation on 1 million trials 589 ms ± 4.78 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) . Not a measurable impact. It could be the different arrays generated in each function (unlikely!!) so lets just time the main trail function itself . print(&quot;Timing v1 trial function&quot;) %timeit MontyTrial(1,2,True) print(&quot;Timing v2 trial function&quot;) %timeit MontyTrialv2(1,2,True) . Timing v1 trial function 202 ns ± 10.1 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) Timing v2 trial function 210 ns ± 60.2 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) . Marginal impact. So lets try a completely different approach. Building this simulator, i have realised: . There is a mathematical function that can return the result of the simulation (thus there will ne no need for conditionals) | A win in the non-switching trial would be a loss in the switching trial (and vice versa) since there are only two doors left to choose from | . So using Numpy there could be a faster implementation. . #Numpy based implementation def MontySimulationv3(trials, supress=False): if (supress == False): print(&quot;Simulating &quot;,trials,&quot; trials in v3 (Numpy Version)&quot;) #Generate a winning and a trial array and compare. A true in this array results in a win in case of no switching Result = np.random.randint(1,4,trials) == np.random.randint(1,4,trials) #If Winning door and the selected doors are the same and there is no switching, then its a win Noswitch_win = Result.sum()/trials if (supress == False): print(&quot;Probability of winning with no switching: &quot;, Noswitch_win) #Winning with switching is 1 - probability of winning without switching print(&quot;Probability of winning with switching: &quot;, 1 - Noswitch_win) . MontySimulationv3(1000000) . Simulating 1000000 trials in v3 (Numpy Version) Probability of winning with no switching: 0.334154 Probability of winning with switching: 0.6658459999999999 . The final version of the simulator uses Numpy only to run trials. All logic is boiled down to a simple comparison of the winning door array and selected door array. Lets find out if that speeds up the model . print(&quot;Timing v1 Simulation on 1 million trials&quot;) %timeit MontySimulation(1000000, True) print(&quot;Timing v2 Simulation on 1 million trials&quot;) %timeit MontySimulationv2(1000000, True) print(&quot;Timing v3 Simulation on 1 million trials&quot;) %timeit MontySimulationv3(1000000, True) . Timing v1 Simulation on 1 million trials 687 ms ± 15.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) Timing v2 Simulation on 1 million trials 638 ms ± 175 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) Timing v3 Simulation on 1 million trials 27 ms ± 1.63 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) . Woah...A Numpy only implementation is almost 10 times faster than my v1 and v2 versions, although all three versions generate their own arrays. Lets modify all three function to accept external arrays so that we can compare the results as well . trials = 1000000 Winning_Door = np.random.randint(1,4,trials) Selected_Door = np.random.randint(1,4,trials) def MontySimulation(trials,Winning_Door,Selected_Door, supress=False): if (supress == False): print(&quot;Simulating &quot;,trials,&quot; trials&quot;) Result = 0 #Running the trial where the contestant never switches for i in range(0, len(Winning_Door)): Result += MontyTrial(Winning_Door[i], Selected_Door[i], False) Result = Result/trials if (supress == False): print(&quot;Probability of winning with no switching: &quot;, Result) print(&quot;Probability of winning with always switching: &quot;, 1 - Result) def MontySimulationv2(trials,Winning_Door,Selected_Door, supress=False): if (supress == False): print(&quot;Simulating &quot;,trials,&quot; trials in v2&quot;) Result = 0 #Running the trial where the contestant never switches for i in range(0, len(Winning_Door)): Result += MontyTrialv2(Winning_Door[i], Selected_Door[i], False) Result = Result/trials if (supress == False): print(&quot;Probability of winning with no switching: &quot;, Result) print(&quot;Probability of winning with always switching: &quot;, 1 - Result) def MontySimulationv3(trials,Winning_Door,Selected_Door, supress=False): if (supress == False): print(&quot;Simulating &quot;,trials,&quot; trials in v3 (Numpy Version)&quot;) #Generate a winning and a trial array and compare. A true in this array results in a win in case of no switching Result = Winning_Door == Selected_Door #If Winning door and the selected doors are the same and there is no switching, then its a win Noswitch_win = Result.sum()/trials if (supress == False): print(&quot;Probability of winning with no switching: &quot;, Noswitch_win) #Winning with switching is 1 - probability of winning without switching print(&quot;Probability of winning with switching: &quot;, 1 - Noswitch_win) . MontySimulation(trials, Winning_Door, Selected_Door) MontySimulationv2(trials, Winning_Door, Selected_Door) MontySimulationv3(trials, Winning_Door, Selected_Door) . Simulating 1000000 trials Probability of winning with no switching: 0.333761 Probability of winning with always switching: 0.666239 Simulating 1000000 trials in v2 Probability of winning with no switching: 0.333761 Probability of winning with always switching: 0.666239 Simulating 1000000 trials in v3 (Numpy Version) Probability of winning with no switching: 0.333761 Probability of winning with switching: 0.666239 . Results from all three versions are the same. Lets do a final timing run for 10 million trials . trials = 10000000 Winning_Door = np.random.randint(1,4,trials) Selected_Door = np.random.randint(1,4,trials) print(&quot;Timing v1 Simulation on 10 million trials&quot;) %timeit MontySimulation(trials, Winning_Door, Selected_Door, True) print(&quot;Timing v2 Simulation on 10 million trials&quot;) %timeit MontySimulationv2(trials, Winning_Door, Selected_Door, True) print(&quot;Timing v3 Simulation on 10 million trials&quot;) %timeit MontySimulationv3(trials, Winning_Door, Selected_Door, True) . Timing v1 Simulation on 10 million trials . The Numpy implementation is now even faster pointing to the fact that generating the random array was the most time consuming part in the v3 algorithm. . Rounding Up . This notebook was my first attempt at implementing a problem and documenting the findings. Along the way I realsied there was further opportunity for me to optimize my code by optimizing my logic and also using faster tools (Numpy) . About the monty hall problem: . It is a well documented problem hence the results were not surprising | This is a significant deviation from the mean with a smaller number of trials, however the values converge for higher number of trials (which is to be expected) | .",
            "url": "https://mindfire83.github.io/deepdive/jupyter/2021/01/21/Exploring-Probability-in-python.html",
            "relUrl": "/jupyter/2021/01/21/Exploring-Probability-in-python.html",
            "date": " • Jan 21, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://mindfire83.github.io/deepdive/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://mindfire83.github.io/deepdive/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://mindfire83.github.io/deepdive/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://mindfire83.github.io/deepdive/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}